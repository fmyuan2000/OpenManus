<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>OpenManus Web</title>
    <style>
      body { font-family: sans-serif; margin: 24px; }
      #log { border: 1px solid #ddd; padding: 12px; height: 60vh; overflow: auto; }
      .msg { margin: 8px 0; white-space: pre-wrap; }
      .role { font-weight: 600; }
      #row { display: flex; gap: 8px; margin-top: 12px; }
      #input { flex: 1; padding: 8px; }
      button { padding: 8px 12px; }
      .msg pre { background: #f6f8fa; padding: 10px; overflow: auto; }
      .msg code { background: #f6f8fa; padding: 2px 4px; }
      .msg pre code { background: transparent; padding: 0; }
    </style>
  </head>
  <body>
    <h2>OpenManus Web Chat</h2>
    <div id="log"></div>
    <div id="row">
      <input id="input" placeholder="Type a message..." />
      <button id="send">Send</button>
      <button id="reset">Reset</button>
    </div>

    <!-- Markdown rendering (sanitized). If your network blocks CDNs, vendor these under /static and update the src. -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.11/dist/purify.min.js"></script>
    <script>
      const log = document.getElementById("log");
      const input = document.getElementById("input");
      const sendBtn = document.getElementById("send");
      const resetBtn = document.getElementById("reset");

      function add(role, text) {
        const div = document.createElement("div");
        div.className = "msg";
        div.innerHTML = `<span class="role">${escapeHtml(role)}:</span> ${renderMarkdown(text)}`;
        log.appendChild(div);
        log.scrollTop = log.scrollHeight;
      }

      function escapeHtml(s) {
        return (s ?? "").toString()
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;");
      }

      function renderMarkdown(text) {
        const t = (text ?? "").toString();
        // Fallback to plain text if markdown libs are unavailable.
        if (!window.marked || !window.DOMPurify) return escapeHtml(t);
        const html = window.marked.parse(t, { breaks: true, gfm: true });
        return window.DOMPurify.sanitize(html);
      }

      let sessionId = null;

      // Realtime voice input (browser speech recognition).
      // Note: This uses the Web Speech API (SpeechRecognition/webkitSpeechRecognition),
      // which is supported in Chromium-based browsers.
      const voiceBtn = document.createElement("button");
      voiceBtn.id = "voice";
      voiceBtn.type = "button";
      voiceBtn.textContent = "语音输入";
      const statusSpan = document.createElement("span");
      statusSpan.id = "voiceStatus";
      statusSpan.style.marginLeft = "8px";
      statusSpan.style.color = "#666";
      statusSpan.textContent = "";
      document.getElementById("row").appendChild(voiceBtn);
      document.getElementById("row").appendChild(statusSpan);

      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      let recognition = null;
      let isListening = false;
      let finalTranscript = "";

      function setVoiceStatus(s) {
        statusSpan.textContent = s || "";
      }

      function updateVoiceButton() {
        voiceBtn.textContent = isListening ? "停止语音" : "语音输入";
      }

      function setupRecognition() {
        if (!SpeechRecognition) return;
        recognition = new SpeechRecognition();
        recognition.lang = "zh-CN";
        recognition.continuous = true;
        recognition.interimResults = true;

        recognition.onstart = () => {
          isListening = true;
          updateVoiceButton();
          setVoiceStatus("正在听...");
        };
        recognition.onerror = (e) => {
          setVoiceStatus("语音错误: " + (e && e.error ? e.error : "unknown"));
          isListening = false;
          updateVoiceButton();
        };
        recognition.onend = () => {
          isListening = false;
          updateVoiceButton();
          setVoiceStatus("");
        };
        recognition.onresult = (event) => {
          let interim = "";
          for (let i = event.resultIndex; i < event.results.length; i++) {
            const res = event.results[i];
            const text = res && res[0] ? res[0].transcript : "";
            if (res.isFinal) finalTranscript += text;
            else interim += text;
          }
          input.value = (finalTranscript + interim).trimStart();
        };
      }

      setupRecognition();
      if (!SpeechRecognition) {
        voiceBtn.disabled = true;
        setVoiceStatus("当前浏览器不支持语音识别");
      }

      voiceBtn.addEventListener("click", () => {
        if (!recognition) return;
        if (!isListening) {
          // Start a new dictation segment; keep existing input as prefix.
          finalTranscript = (input.value || "").trim();
          if (finalTranscript) finalTranscript += " ";
          try {
            recognition.start();
          } catch (_) {
            // Some browsers throw if start() is called twice quickly.
          }
        } else {
          recognition.stop();
        }
      });

      async function ensureSession() {
        if (sessionId) return sessionId;
        const r = await fetch("/api/new", { method: "POST" });
        const j = await r.json();
        sessionId = j.session_id;
        return sessionId;
      }

      async function send() {
        const text = input.value.trim();
        if (!text) return;
        input.value = "";
        add("user", text);
        const sid = await ensureSession();
        const r = await fetch("/api/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sid, message: text }),
        });
        const j = await r.json();
        add("assistant", j.reply || "");
      }

      async function reset() {
        if (!sessionId) return;
        const r = await fetch("/api/reset", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sessionId }),
        });
        const j = await r.json();
        sessionId = j.session_id;
        log.innerHTML = "";
        add("system", "session reset");
      }

      sendBtn.addEventListener("click", send);
      resetBtn.addEventListener("click", reset);
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          send();
        }
      });
    </script>
  </body>
</html>
